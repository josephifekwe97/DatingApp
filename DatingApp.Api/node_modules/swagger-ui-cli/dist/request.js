"use strict";
/**
 * swagger-ui-cli - Standalone Swagger UI server
 * Copyright (C) 2020  e.GO Digital GmbH, Aachen, Germany
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const crypto_1 = __importDefault(require("crypto"));
const mime_types_1 = __importDefault(require("mime-types"));
const path_1 = __importDefault(require("path"));
const swagger_ui_dist_1 = require("swagger-ui-dist");
const contracts_1 = require("./contracts");
const globals_1 = require("./globals");
const templates_1 = require("./templates");
const utils_1 = require("./utils");
const fileCache = {};
const swaggerUIDir = path_1.default.resolve(swagger_ui_dist_1.getAbsoluteFSPath());
/**
 * Creates a new HTTP request handler.
 *
 * @returns {RequestListener} The new handler.
 */
exports.default = () => {
    const lastModified = new Date().toUTCString();
    const etagPrefix = `${utils_1.hashData(Buffer.from(lastModified, 'utf8'))}-${crypto_1.default.randomBytes(4).toString('hex')}-`;
    const createHeaders = (headers) => (Object.assign({ 'Last-Modified': lastModified }, headers));
    const etag = (data, hash) => {
        if (typeof hash !== 'string') {
            hash = utils_1.hashData(data);
        }
        return {
            'Content-Length': data.length,
            ETag: `"${etagPrefix}${hash}"`
        };
    };
    const indexHtml = Buffer.from(templates_1.indexHtml.replace('<% title %>', 'Swagger UI')
        .replace('<% favIconString %>', templates_1.defaultFavIcon)
        // .replace('<% customJsUrl %>', jsUrl ? `<script src="${jsUrl}"></script>` : '')
        .replace('<% customJsUrl %>', '')
        // .replace('<% customCssUrl %>', cssUrl ? `<link href="${cssUrl}" rel="stylesheet">` : '')
        .replace('<% customCssUrl %>', '')
        .replace('<% customCss %>', '')
        // .replace('<% customJs %>', customJs ? `<script> ${customJs} </script>` : '')
        .replace('<% customJs %>', ''), contracts_1.DEFAULT_CHARSET);
    const indexHtmlContentType = `text/html; charset=${contracts_1.DEFAULT_CHARSET_HTTP}`;
    const indexHtmlHash = utils_1.hashData(indexHtml);
    return async (req, res) => {
        var _a;
        try {
            for (const name in globals_1.swaggerDocuments) {
                const basePath = '/' + name;
                const url = (_a = req.url) === null || _a === void 0 ? void 0 : _a.split(path_1.default.sep).join('/').trim();
                if (!(url === null || url === void 0 ? void 0 : url.startsWith(basePath))) {
                    continue;
                }
                const relUrl = utils_1.normalizePath(url.substr(basePath.length));
                const swaggerDoc = globals_1.swaggerDocuments[name];
                const contentDisposition = (ext) => ({
                    'Content-Disposition': `attachment; filename="${swaggerDoc.fileName}.${ext}`
                });
                // index.html
                if (['/', '/index.html'].includes(relUrl)) {
                    res.writeHead(200, createHeaders(Object.assign(Object.assign({}, etag(indexHtml, indexHtmlHash)), { 'Content-Type': indexHtmlContentType })));
                    res.end(indexHtml);
                    return;
                }
                // swagger-ui-init.js
                if (relUrl.startsWith('/swagger-ui-init.js')) {
                    const js = Buffer.from(templates_1.swaggerUiInit.replace('<% swaggerOptions %>', `var options = ${JSON.stringify({
                        // swaggerDoc: options.document || undefined,
                        swaggerDoc: swaggerDoc.object,
                        // customOptions: options.uiOptions || {},
                        customOptions: {},
                        swaggerUrl: basePath + '/json'
                    })}`), contracts_1.DEFAULT_CHARSET);
                    res.writeHead(200, createHeaders(Object.assign(Object.assign({}, etag(js)), { 'Content-Type': contracts_1.CONTENT_TYPE_JAVASCRIPT })));
                    res.end(js);
                    return;
                }
                // JSON download
                if (relUrl.startsWith('/json')) {
                    res.writeHead(200, createHeaders(Object.assign(Object.assign(Object.assign({}, etag(swaggerDoc.json)), { 'Content-Type': contracts_1.CONTENT_TYPE_JSON }), contentDisposition('json'))));
                    res.end(swaggerDoc.json);
                    return;
                }
                // YAML download
                if (relUrl.startsWith('/yaml')) {
                    res.writeHead(200, createHeaders(Object.assign(Object.assign(Object.assign({}, etag(swaggerDoc.yaml)), { 'Content-Type': contracts_1.CONTENT_TYPE_YAML }), contentDisposition('yaml'))));
                    res.end(swaggerDoc.yaml);
                    return;
                }
                // TOML download
                if (relUrl.startsWith('/toml')) {
                    res.writeHead(200, createHeaders(Object.assign(Object.assign(Object.assign({}, etag(swaggerDoc.toml)), { 'Content-Type': contracts_1.CONTENT_TYPE_TOML }), contentDisposition('toml'))));
                    res.end(swaggerDoc.toml);
                    return;
                }
                const file = path_1.default.resolve(path_1.default.join(swaggerUIDir, relUrl));
                let cacheEntry = fileCache[file];
                const sendCacheEntry = () => {
                    res.writeHead(200, createHeaders(Object.assign(Object.assign({}, etag(cacheEntry.content, cacheEntry.hash)), { 'Content-Type': cacheEntry.mime })));
                    res.end(cacheEntry.content);
                };
                if (!cacheEntry) {
                    if (file.startsWith(swaggerUIDir + path_1.default.sep)) {
                        if (await utils_1.exists(file)) {
                            const fileStat = await utils_1.stat(file);
                            if (fileStat.isFile()) {
                                const content = await utils_1.readFile(file);
                                const mime = mime_types_1.default.lookup(file) || 'application/octet-stream';
                                const hash = utils_1.hashData(content);
                                fileCache[file] = cacheEntry = {
                                    content,
                                    hash,
                                    mime
                                };
                            }
                        }
                    }
                }
                if (cacheEntry) {
                    sendCacheEntry();
                    return;
                }
                break;
            }
            res.writeHead(404);
            res.end();
        }
        catch (e) {
            console.error('[ERROR]', e);
            if (!res.headersSent) {
                res.writeHead(500);
            }
            res.end();
        }
    };
};
//# sourceMappingURL=request.js.map