"use strict";
/**
 * swagger-ui-cli - Standalone Swagger UI server
 * Copyright (C) 2020  e.GO Digital GmbH, Aachen, Germany
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createLocalFileDocReader = exports.createHttpDocReader = void 0;
// THIS HAS TO BE VERY FIRST!
const cli_1 = __importDefault(require("./cli"));
const axios_1 = __importDefault(require("axios"));
const content_type_1 = __importDefault(require("content-type"));
const toml_1 = __importDefault(require("@iarna/toml"));
const js_yaml_1 = __importDefault(require("js-yaml"));
const cli_2 = require("./cli");
const contracts_1 = require("./contracts");
const utils_1 = require("./utils");
const code_1 = require("./code");
const canExecuteScripts = cli_1.default.flags.allowScripts;
/**
 * Creates a document reader, which reads from HTTP(s) source.
 *
 * @param {string} swaggerUri The source URL.
 *
 * @returns {DocumentReader} The new reader.
 */
function createHttpDocReader(swaggerUri) {
    return async () => {
        var _a, _b, _c;
        // supported content type by file extension
        let supportedTypeByFileExt;
        if (swaggerUri.endsWith('.json')) {
            supportedTypeByFileExt = contracts_1.MIME_JSON;
        }
        else if (swaggerUri.endsWith('.yaml') || swaggerUri.endsWith('.yml')) {
            supportedTypeByFileExt = contracts_1.MIME_YAML;
        }
        else if (swaggerUri.endsWith('.toml')) {
            supportedTypeByFileExt = contracts_1.MIME_TOML;
        }
        else if (swaggerUri.endsWith('.js')) {
            supportedTypeByFileExt = contracts_1.MIME_JAVASCRIPT;
        }
        const resp = await utils_1.withSpinner(`Download from ${swaggerUri}`, () => axios_1.default.get(swaggerUri, {
            responseType: 'arraybuffer'
        }), 'ðŸšš');
        const getStringData = (enc) => {
            try {
                return resp.data.toString(enc);
            }
            catch (_a) { }
            return resp.data.toString(contracts_1.DEFAULT_CHARSET);
        };
        const tryParseDoc = async (type, enc = contracts_1.DEFAULT_CHARSET) => {
            if (type === null || type === void 0 ? void 0 : type.endsWith('json')) {
                return JSON.parse(getStringData(enc));
            }
            else if (type === null || type === void 0 ? void 0 : type.endsWith('yaml')) {
                return js_yaml_1.default.safeLoad(getStringData(enc));
            }
            else if (type === null || type === void 0 ? void 0 : type.endsWith('toml')) {
                return toml_1.default.parse(getStringData(enc));
            }
            else if (canExecuteScripts && (type === null || type === void 0 ? void 0 : type.endsWith('javascript'))) {
                return await code_1.executeCode(getStringData(enc));
            }
            return contracts_1.NOT_SUPPORTED;
        };
        let doc = contracts_1.NOT_SUPPORTED;
        const contentTypeHeader = (_a = resp.headers) === null || _a === void 0 ? void 0 : _a['content-type'];
        if (typeof contentTypeHeader === 'string') {
            const ct = content_type_1.default.parse(contentTypeHeader);
            const charset = (_b = ct.parameters['charset']) === null || _b === void 0 ? void 0 : _b.toLowerCase().trim().split('-').join('');
            const enc = charset || contracts_1.DEFAULT_CHARSET;
            let type = (_c = ct.type) === null || _c === void 0 ? void 0 : _c.toLowerCase().trim();
            if (type === null || type === void 0 ? void 0 : type.endsWith('json')) {
                type = contracts_1.MIME_JSON;
            }
            else if (type === null || type === void 0 ? void 0 : type.endsWith('yaml')) {
                type = contracts_1.MIME_YAML;
            }
            else if (type === null || type === void 0 ? void 0 : type.endsWith('toml')) {
                type = contracts_1.MIME_TOML;
            }
            else if (type === null || type === void 0 ? void 0 : type.endsWith('javascript')) {
                type = contracts_1.MIME_JAVASCRIPT;
            }
            // try parse by content type
            doc = await tryParseDoc(type, enc);
        }
        if (doc === contracts_1.NOT_SUPPORTED) {
            // now try by file extension
            doc = await tryParseDoc(supportedTypeByFileExt);
        }
        if (doc === contracts_1.NOT_SUPPORTED) {
            showInvalidDocumentError(swaggerUri);
        }
        return doc;
    };
}
exports.createHttpDocReader = createHttpDocReader;
/**
 * Creates a document reader, which reads from HTTP(s) source.
 *
 * @param {string} swaggerFile The path to Swagger document file.
 *
 * @returns {DocumentReader} The new reader.
 */
function createLocalFileDocReader(swaggerFile) {
    return async () => {
        const swaggerFileStat = await utils_1.stat(swaggerFile);
        if (!swaggerFileStat.isFile()) {
            cli_2.exitWith(contracts_1.ExitCode.NoFile, `${swaggerFile} is no file!`);
        }
        if (swaggerFile.endsWith('.json')) {
            return JSON.parse(await utils_1.readFile(swaggerFile, contracts_1.DEFAULT_CHARSET));
        }
        else if (swaggerFile.endsWith('.yaml') || swaggerFile.endsWith('.yml')) {
            return js_yaml_1.default.safeLoad(await utils_1.readFile(swaggerFile, contracts_1.DEFAULT_CHARSET));
        }
        else if (swaggerFile.endsWith('.toml')) {
            return toml_1.default.parse(await utils_1.readFile(swaggerFile, contracts_1.DEFAULT_CHARSET));
        }
        else if (canExecuteScripts && swaggerFile.endsWith('.js')) {
            return code_1.executeCode(await utils_1.readFile(swaggerFile, contracts_1.DEFAULT_CHARSET));
        }
        showInvalidDocumentError(swaggerFile);
    };
}
exports.createLocalFileDocReader = createLocalFileDocReader;
function showInvalidDocumentError(pathOrUri) {
    const allowedExtensions = ['json', 'toml', 'yaml', 'yml'];
    if (canExecuteScripts) {
        allowedExtensions.unshift('js');
    }
    cli_2.exitWith(contracts_1.ExitCode.InvalidDocumentFormat, `${pathOrUri} must be of one of the following types: ${allowedExtensions.join(', ')}!`);
}
//# sourceMappingURL=docs.js.map